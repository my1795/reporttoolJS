{"ast":null,"code":"\"use strict\";\n/*\n  wmic calls must always be serialised in windows, hence the use of async.queue\n*/\n\nvar spawn = require('child_process').spawn,\n    exec = require('child_process').exec,\n    async = require('async'),\n    fs = require('fs'),\n    iconv = require('iconv-lite');\n/**\n * Need to split a command line string taking into account strings - that is, don't\n * split spaces within a string. So that 'P1 P2 \"Other Param\" P4' is split into 4 param strings\n * with param 3 = \"Other Param\" (not including quotes).\n **/\n\n\nvar splitter = function splitter(cmd) {\n  cmd = cmd.trim();\n  var acc = [],\n      inString = false,\n      cur = \"\",\n      l = cmd.length;\n\n  for (var i = 0; i < l; i++) {\n    var ch = cmd.charAt(i);\n\n    switch (ch) {\n      case '\"':\n        inString = !inString;\n\n        if (!inString) {\n          if (cur.length > 0) {\n            acc.push(cur);\n            cur = \"\";\n          }\n        }\n\n        break;\n\n      case ' ':\n        if (inString) {\n          cur += ' ';\n        } else {\n          if (cur.length > 0) {\n            acc.push(cur);\n            cur = \"\";\n          }\n        }\n\n        break;\n\n      default:\n        cur += ch;\n        break;\n    }\n  }\n\n  if (cur.length > 0) acc.push(cur);\n  return acc;\n};\n\nvar parse_list = function parse_list(data) {\n  var blocks = data.split(/\\n\\n|\\n,?\\r/g).filter(function (block) {\n    return block.length > 2;\n  });\n  var list = [];\n  blocks.forEach(function (block) {\n    var obj = {},\n        lines = block.split(/\\n+|\\r+/).filter(function (line) {\n      return line.indexOf('=') !== -1;\n    });\n    lines.forEach(function (line) {\n      var kv = line.replace(/^,/, '').split(\"=\");\n      obj[kv[0]] = kv[1];\n    });\n    if (Object.keys(obj).length > 0) list.push(obj);\n  });\n  return list;\n};\n\nvar parse_values = function parse_values(out) {\n  var arr = [];\n  var data = buildDataArray(out);\n  var keys = data[0];\n  data.forEach(function (k, i) {\n    if (k != keys) {\n      var obj = {};\n      k.forEach(function (l, j) {\n        obj[keys[j]] = l;\n      });\n      arr.push(obj);\n    }\n  });\n  return arr;\n};\n\nfunction buildDataArray(rawInput) {\n  var lines = rawInput.toString().trim().split('\\n');\n  var data = [];\n  var keys = [];\n  var linePattern = /(\\S*?\\s\\s+)/g;\n  var match;\n\n  while ((match = linePattern.exec(lines[0])) !== null) {\n    if (match.index === linePattern.lastIndex) {\n      linePattern.lastIndex++;\n    }\n\n    var key = {};\n    key.string = match[0].trim();\n    key.startPoint = lines[0].indexOf(key.string);\n    key.keyLength = match[0].length;\n    keys.push(key);\n  }\n\n  lines.forEach(function (line, index) {\n    var lineData = [];\n    keys.forEach(function (key, jndex) {\n      lineData.push(line.substr(key.startPoint, key.keyLength).trim());\n    });\n    data.push(lineData);\n  });\n  return data;\n}\n/**\n * Run the wmic command provided.\n *\n * The resulting output string has an additional pid property added so, one may get the process\n * details. This seems the easiest way of doing so given the run is in a queue.\n **/\n\n\nvar run = exports.run = function (cmd, cb) {\n  queue.push(cmd, cb);\n}; // The encoding is cached in this variable, so the CHCP command is executed only once.\n\n\nvar consoleEncoding;\nvar queue = async.queue(function (cmd, cb) {\n  var opts = {\n    env: process.env,\n    cwd: process.env.TEMP\n  };\n\n  if (opts.env.PATH.indexOf('system32') === -1) {\n    opts.env.PATH += ';' + process.env.WINDIR + \"\\\\system32\";\n    opts.env.PATH += ';' + process.env.WINDIR + \"\\\\system32\\\\wbem\";\n  }\n\n  var pid;\n  async.parallel([function (cb) {\n    if (consoleEncoding) {\n      cb(null, consoleEncoding);\n    } else {\n      exec('chcp', function (err, stdout) {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        var codePage = stdout.replace(/\\D/g, '');\n        consoleEncoding = codePage && codePage !== '65001' ? 'cp' + codePage : 'utf8';\n        cb(null, consoleEncoding);\n      });\n    }\n  }, function (cb) {\n    var wm = spawn('wmic', splitter(cmd), opts),\n        stdout = [],\n        stderr = [];\n    pid = wm.pid;\n    wm.on('error', function (e) {\n      if (e.code == 'ENOENT') e.message = 'Unable to find wmic command in path.';\n      cb(e);\n    });\n    wm.stdout.on('data', function (d) {\n      // console.log('Got out: ' + d.toString())\n      stdout.push(d);\n    });\n    wm.stderr.on('data', function (e) {\n      // console.log('Got error: ' + e.toString())\n      stderr.push(e);\n    });\n    wm.on('exit', function (code) {\n      // remove weird temp file generated by wmic\n      fs.unlink('TempWmicBatchFile.bat', function () {\n        /* noop */\n      });\n      process.nextTick(function () {\n        cb(null, [stdout, stderr]);\n      });\n    });\n    wm.stdin.end();\n  }], function (err, results) {\n    if (!err) {\n      var encoding = results[0];\n      var stdoutStr = stringifyBufferArray(results[1][0], encoding);\n      var stderrStr = stringifyBufferArray(results[1][1], encoding);\n\n      if (stderrStr) {\n        err = new Error(stderrStr);\n      }\n\n      cb(err, stdoutStr, pid);\n    } else {\n      cb(err, '', pid);\n    }\n  });\n\n  function stringifyBufferArray(array, encoding) {\n    return array.map(function (buffer) {\n      return iconv.decode(buffer, encoding);\n    }).join(',').replace(/^,/, '').replace(/,\\s+$/, '').trim();\n  }\n});\n\nexports.get_value = function (section, value, condition, cb) {\n  var cond = condition ? ' where \"' + condition + '\" ' : '';\n  var cmd = section + cond + ' get ' + value + ' /value';\n  run(cmd, function (err, out) {\n    if (err) return cb(err);\n    var str = out.match(/=(.*)/);\n    if (str) cb(null, str[1].trim());else cb(new Error(\"Wmic: Couldn't get \" + value + \" in \" + section));\n  });\n};\n\nexports.get_values = function (section, keys, condition, cb) {\n  var cond = condition ? ' where \"' + condition + '\" ' : '';\n  var cmd = section + cond + ' get ' + keys;\n  run(cmd, function (err, out) {\n    if (err) return cb(err);\n    cb(null, parse_values(out));\n  });\n};\n/**\n * Calls back an array of objects for the given command.\n *\n * This only works for alias commands with a LIST clause.\n **/\n\n\nexports.get_list = function (cmd, callback) {\n  run(cmd + ' list full', function (err, data) {\n    if (err) return callback(err);\n    callback(null, parse_list(data));\n  });\n};","map":null,"metadata":{},"sourceType":"script"}