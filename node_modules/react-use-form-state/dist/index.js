'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * Shallowly merge newState into state
 */
function stateReducer(state, newState) {
  return _objectSpread({}, state, newState);
}

/**
 * Cast non-string values to a string, with the exception of functions, symbols,
 * and undefined.
 */
function toString(value) {
  switch (_typeof(value)) {
    case 'function':
    case 'symbol':
    case 'undefined':
      return '';

    default:
      return '' + value;
    // eslint-disable-line prefer-template
  }
}

var CHECKBOX = 'checkbox';
var COLOR = 'color';
var DATE = 'date';
var EMAIL = 'email';
var MONTH = 'month';
var NUMBER = 'number';
var PASSWORD = 'password';
var RADIO = 'radio';
var RANGE = 'range';
var SEARCH = 'search';
var SELECT = 'select';
var SELECT_MULTIPLE = 'selectMultiple';
var TEL = 'tel';
var TEXT = 'text';
var TEXTAREA = 'textarea';
var TIME = 'time';
var URL = 'url';
var WEEK = 'week';
var TYPES = [CHECKBOX, COLOR, DATE, EMAIL, MONTH, NUMBER, PASSWORD, RADIO, RANGE, SEARCH, SELECT, SELECT_MULTIPLE, TEL, TEXT, TEXTAREA, TIME, URL, WEEK];

function noop() {}

var defaultFromOptions = {
  onChange: noop,
  onBlur: noop,
  onTouched: noop
};
function useFormState(initialState, options) {
  var formOptions = _objectSpread({}, defaultFromOptions, options);

  var _useReducer = react.useReducer(stateReducer, initialState || {}),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      setState = _useReducer2[1];

  var _useReducer3 = react.useReducer(stateReducer, {}),
      _useReducer4 = _slicedToArray(_useReducer3, 2),
      touched = _useReducer4[0],
      setTouchedState = _useReducer4[1];

  var _useReducer5 = react.useReducer(stateReducer, {}),
      _useReducer6 = _slicedToArray(_useReducer5, 2),
      validity = _useReducer6[0],
      setValidityState = _useReducer6[1];

  var createPropsGetter = function createPropsGetter(type) {
    return function (name, ownValue) {
      var hasOwnValue = !!toString(ownValue);
      var hasValueInState = state[name] !== undefined;
      var isCheckbox = type === CHECKBOX;
      var isRadio = type === RADIO;
      var isSelectMultiple = type === SELECT_MULTIPLE;

      function setInitialValue() {
        var value = '';

        if (isCheckbox) {
          /**
           * If a checkbox has a user-defined value, its value the form state
           * value will be an array. Otherwise it will be considered a toggle.
           */
          value = hasOwnValue ? [] : false;
        }

        if (isSelectMultiple) {
          value = [];
        }

        setState(_defineProperty({}, name, value));
      }

      function getNextCheckboxValue(e) {
        var _e$target = e.target,
            value = _e$target.value,
            checked = _e$target.checked;

        if (!hasOwnValue) {
          return checked;
        }

        var checkedValues = new Set(state[name]);

        if (checked) {
          checkedValues.add(value);
        } else {
          checkedValues.delete(value);
        }

        return Array.from(checkedValues);
      }

      function getNextSelectMultipleValue(e) {
        return Array.from(e.target.options).reduce(function (values, option) {
          return option.selected ? _toConsumableArray(values).concat([option.value]) : values;
        }, []);
      }

      var inputProps = {
        name: name,

        get type() {
          if (type !== SELECT && type !== SELECT_MULTIPLE && type !== TEXTAREA) return type;
        },

        get multiple() {
          if (type === SELECT_MULTIPLE) return true;
        },

        get checked() {
          if (isRadio) {
            return state[name] === toString(ownValue);
          }

          if (isCheckbox) {
            if (!hasOwnValue) {
              return state[name] || false;
            }
            /**
             * @todo Handle the case where two checkbox inputs share the same
             * name, but one has a value, the other doesn't (throws currently).
             * <input {...input.checkbox('option1')} />
             * <input {...input.checkbox('option1', 'value_of_option1')} />
             */


            return hasValueInState ? state[name].includes(toString(ownValue)) : false;
          }
        },

        get value() {
          // auto populating initial state values on first render
          if (!hasValueInState) {
            setInitialValue();
          }
          /**
           * Since checkbox and radio inputs have their own user-defined values,
           * and since checkbox inputs can be either an array or a boolean,
           * returning the value of input from the current form state is illogical
           */


          if (isCheckbox || isRadio) {
            return toString(ownValue);
          }

          return hasValueInState ? state[name] : '';
        },

        onChange: function onChange(e) {
          var value = e.target.value;

          if (isCheckbox) {
            value = getNextCheckboxValue(e);
          }

          if (isSelectMultiple) {
            value = getNextSelectMultipleValue(e);
          }

          var partialNewState = _defineProperty({}, name, value);

          var newState = _objectSpread({}, state, partialNewState);

          formOptions.onChange(e, state, newState);
          setState(partialNewState);
        },
        onBlur: function onBlur(e) {
          if (!touched[name]) {
            formOptions.onTouched(e);
          }

          formOptions.onBlur(e);
          setTouchedState(_defineProperty({}, name, true));
          setValidityState(_defineProperty({}, name, e.target.validity.valid));
        }
      };
      return inputProps;
    };
  };

  var inputPropsCreators = TYPES.reduce(function (methods, type) {
    return _objectSpread({}, methods, _defineProperty({}, type, createPropsGetter(type)));
  }, {});
  return [{
    values: state,
    validity: validity,
    touched: touched
  }, inputPropsCreators];
}

exports.useFormState = useFormState;
